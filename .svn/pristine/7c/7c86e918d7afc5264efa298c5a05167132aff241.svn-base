package com.efun.mainland.util.db;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.core.NestedRuntimeException;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource;
import org.springframework.transaction.interceptor.RuleBasedTransactionAttribute;
import org.springframework.transaction.interceptor.TransactionAttribute;
import org.springframework.util.PatternMatchUtils;
import org.springframework.util.ReflectionUtils;
import com.efun.mainland.util.db.annotation.SelectDataBase;

public class DBProcessor implements BeanPostProcessor {
	private static final Logger log = LoggerFactory.getLogger(DBProcessor.class);

	private boolean forceChoiceReadWhenWrite = false;

	private Map<String, Boolean> readMethodMap = new HashMap<String, Boolean>();

	public void setForceChoiceReadWhenWrite(boolean forceChoiceReadWhenWrite) {

		this.forceChoiceReadWhenWrite = forceChoiceReadWhenWrite;
	}

	@SuppressWarnings("unchecked")
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {

		if (!(bean instanceof NameMatchTransactionAttributeSource)) {
			return bean;
		}

		try {
			NameMatchTransactionAttributeSource transactionAttributeSource = (NameMatchTransactionAttributeSource) bean;
			Field nameMapField = ReflectionUtils.findField(NameMatchTransactionAttributeSource.class, "nameMap");
			nameMapField.setAccessible(true);
			Map<String, TransactionAttribute> nameMap = (Map<String, TransactionAttribute>) nameMapField
					.get(transactionAttributeSource);

			for (Entry<String, TransactionAttribute> entry : nameMap.entrySet()) {
				RuleBasedTransactionAttribute attr = (RuleBasedTransactionAttribute) entry.getValue();

				if (!attr.isReadOnly()) {
					continue;
				}

				String methodName = entry.getKey();
				Boolean isForceChoiceRead = Boolean.FALSE;
				if (forceChoiceReadWhenWrite) {
					attr.setPropagationBehavior(Propagation.NOT_SUPPORTED.value());
					isForceChoiceRead = Boolean.TRUE;
				} else {
					attr.setPropagationBehavior(Propagation.SUPPORTS.value());
				}
				log.debug("read/write transaction process  method:{} force read:{}", methodName, isForceChoiceRead);
				readMethodMap.put(methodName, isForceChoiceRead);
			}

		} catch (Exception e) {
			throw new ReadWriteDataSourceTransactionException("process read/write transaction error", e);
		}

		return bean;
	}

	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}

	private class ReadWriteDataSourceTransactionException extends NestedRuntimeException {
		/**
		 * 
		 */
		private static final long serialVersionUID = -8440271125464118921L;

		public ReadWriteDataSourceTransactionException(String message, Throwable cause) {
			super(message, cause);
		}
	}

	public Object determineReadOrWriteDB(ProceedingJoinPoint pjp) throws Throwable {
		Method method = ((MethodSignature) pjp.getSignature()).getMethod();

		SelectDataBase selectDataBase = method.getAnnotation(SelectDataBase.class);
		SelectDataBase.DataBase dataBase = null;
		if (selectDataBase != null) {
			dataBase = selectDataBase.value();
			log.debug("@SelectDataBase:method select {}", dataBase);
		}

		if (dataBase == null) {
			SelectDataBase targetSelectDataBase = pjp.getTarget().getClass().getAnnotation(SelectDataBase.class);
			if (targetSelectDataBase != null) {
				dataBase = targetSelectDataBase.value();
				log.debug("@SelectDataBase:target select {}", dataBase);
			}
		}

		Object[] args = pjp.getArgs();
		if (args != null && args.length > 0 && args[0] != null && (args[0] instanceof SelectDataBase.DataBase)) {
			dataBase = (SelectDataBase.DataBase) args[0];
			log.debug("@SelectDataBase:special select {}", dataBase);
		}

		if (dataBase == null) {
			dataBase = DBDataSource.getDefaultDB();
			log.debug("@SelectDataBase is null,select {}(dedault)", dataBase);
		}

		ReadOnlyDecision.set(isChoiceReadDB(pjp.getSignature().getName()));
		ThreadSafeDataBaseConnection.set(dataBase);
		try {
			return pjp.proceed();
		} catch (Throwable th) {
			log.error("SQL excute exception:DB={},readOnly={},target={},method={},@SelectDataBase={},message={}", ThreadSafeDataBaseConnection.get(),
					ReadOnlyDecision.get(), pjp.getTarget(), pjp.getSignature().getName(), selectDataBase, th.getMessage());
			throw th;
		} finally {
			ReadOnlyDecision.remove();
			ThreadSafeDataBaseConnection.remove();
		}
	}

	private boolean isChoiceReadDB(String methodName) {

		String bestNameMatch = null;
		for (String mappedName : this.readMethodMap.keySet()) {
			if (isMatch(methodName, mappedName)) {
				bestNameMatch = mappedName;
				break;
			}
		}
		if (bestNameMatch != null) {
			Boolean isForceChoiceRead = readMethodMap.get(bestNameMatch);
			if (isForceChoiceRead == Boolean.TRUE) {
				return true;
			}
		}

		return false;
	}

	protected boolean isMatch(String methodName, String mappedName) {
		return PatternMatchUtils.simpleMatch(mappedName, methodName);
	}

}
