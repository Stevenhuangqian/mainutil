package com.efun.mainland.util.redis;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.apache.log4j.Logger;

import com.efun.mainland.util.CacheUtil;
import com.efun.mainland.util.CommonUtil;
import com.efun.mainland.util.PropertiesCacheUtil;
import com.efun.mainland.util.PropertiesFileLoader;

import redis.clients.jedis.ShardedJedis;

/**
 * redis客户端一致性哈希集群配置
 * 
 * @author Administrator
 * 
 */
public final class Redis {
	private Redis() {
	}

	/**
	 * redis配置文件<br/>
	 * classpath目录
	 */
	public static final String REDIS_CONFIG_FILE = "redis.properties";
	
	private static final Logger log = Logger.getLogger(Redis.class);
	private static ShardedJedisSentinelPool2 pool = null;
	private static AtomicBoolean poolState = new AtomicBoolean(false);

	/**
	 * 为了避免数据库主从同步延迟导致的问题，需要再次删除缓存key值的队列key
	 */
	private static String CACHE_KEYS_QUEUE_STRING;
	private static byte[] CACHE_KEYS_QUEUE_BYTE;

	static {
		CACHE_KEYS_QUEUE_STRING = CacheUtil.getCachePrefix() + "_CACHE_KEYS_QUEUE_STRING";
		
		try {
			CACHE_KEYS_QUEUE_BYTE = (CacheUtil.getCachePrefix() + "_CACHE_KEYS_QUEUE_BYTE").getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			log.error("UTF-8 UnsupportedEncoding", e);
		}
		
		initPool();
	}
	
	/**
	 * 为了避免数据库主从同步延迟导致的问题，需要再次删除缓存key值的队列key
	 */
	public static final String getCacheQueueKeyString(){
		return CACHE_KEYS_QUEUE_STRING;
	}
	
	/**
	 * 为了避免数据库主从同步延迟导致的问题，需要再次删除缓存key值的队列key
	 */
	public static final byte[] getCacheQueueKeyByte(){
		return CACHE_KEYS_QUEUE_BYTE;
	}

	synchronized protected final static boolean initPool() {
		if(Charset.isSupported("UTF-8")){
			System.out.println("UTF-8 Charset SupportedEncoding");
			log.info("UTF-8 Charset SupportedEncoding");
		}else{
			System.out.println("UTF-8 Charset UnsupportedEncoding");
			log.error("UTF-8 Charset UnsupportedEncoding");
			return false;
		}
		try {
			if (poolState.getAndSet(true)) {
				return true;
			}
			destroyPool();

			GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
			poolConfig
					.setMaxIdle(Integer.valueOf(PropertiesCacheUtil.getValue("redis.pool.maxIdle", REDIS_CONFIG_FILE)));
			poolConfig.setMaxWaitMillis(
					Long.valueOf(PropertiesCacheUtil.getValue("redis.pool.maxWait", REDIS_CONFIG_FILE)));
			poolConfig.setTestOnBorrow(
					Boolean.valueOf(PropertiesCacheUtil.getValue("redis.pool.testOnBorrow", REDIS_CONFIG_FILE)));
			poolConfig.setTestOnReturn(
					Boolean.valueOf(PropertiesCacheUtil.getValue("redis.pool.testOnReturn", REDIS_CONFIG_FILE)));
			poolConfig.setMaxTotal(
					Integer.valueOf(PropertiesCacheUtil.getValue("redis.pool.maxActive", REDIS_CONFIG_FILE)));

			int timeout = Integer.valueOf(PropertiesCacheUtil.getValue("redis.pool.timeout", REDIS_CONFIG_FILE));

			// 以|隔开
			String servers = PropertiesCacheUtil.getValue("redis.serverNames", REDIS_CONFIG_FILE);
			String sentinels = PropertiesCacheUtil.getValue("redis.sentinels", REDIS_CONFIG_FILE);
			List<String> serverNameList = new ArrayList<String>();
			Set<String> sentinelSet = new HashSet<String>();
			String[] names = new String[0];
			String[] sents = new String[0];

			if (servers != null && servers.trim().length() > 0) {
				names = servers.split("\\||\\,");
			}
			if (sentinels != null && sentinels.trim().length() > 0) {
				sents = sentinels.split("\\||\\,");
			}
			for (String str : names) {
				if (str.trim().length() != 0) {
					serverNameList.add(str);
				}
			}
			for (String str : sents) {
				if (str.trim().length() != 0) {
					sentinelSet.add(str);
				}
			}
			log.info(new StringBuilder().append("redis.serverNames>>>").append(servers).toString());
			log.info(new StringBuilder().append("redis.sentinels>>>").append(sentinels).toString());
			System.out.println(new StringBuilder().append("redis.serverNames>>>").append(servers).toString());
			System.out.println(new StringBuilder().append("redis.sentinels>>>").append(sentinels).toString());
			
			Set<String> nameSet=new LinkedHashSet<String>(serverNameList);
			pool = new ShardedJedisSentinelPool2(nameSet, sentinelSet, poolConfig, timeout);
			if (pool == null) {
				log.error("ShardedJedisSentinelPool init fail");
				System.out.println("ShardedJedisSentinelPool init fail");
			} else {
				log.info("ShardedJedisSentinelPool init success:" + pool.toString());
				System.out.println("ShardedJedisSentinelPool init success:" + pool.toString());
				return true;
			}
		} catch (Exception e) {
			System.out.println(
					"[redis.properties]{" + PropertiesFileLoader.getClassPath() + "} 属性文件中属性配置错误!" + e.getMessage());
			log.error("[redis.properties]{" + PropertiesFileLoader.getClassPath() + "} 属性文件中属性配置错误!" + e.getMessage(),
					e);
		}
		return false;
	}

	synchronized protected final static void destroyPool() {
		try {
			if (pool != null) {
				pool.destroy();
				System.out.println("ShardedJedisSentinelPool destroy success");
				log.info("ShardedJedisSentinelPool destroy success");
			}
		} catch (Exception e) {
			log.error("ShardedJedisSentinelPool destroy error:" + e.getMessage(), e);
		} finally {
			pool = null;
		}
	}

	protected final static ShardedJedis getRedis() {
		return getRedis(false);
	}
	
	/**
	 * 
	 * @param readonly 是否只读，暂不判断该参数，全部操作主库
	 * @return
	 */
	protected final static ShardedJedis getRedis(boolean readonly) {
		return pool.getResource();
	}

	protected final static void releaseRedis(ShardedJedis redis) {
		if (redis == null) {
			log.error("releaseRedis error:redis is null");
			return;
		}
		try {
			redis.close();
		} catch (Exception e) {
			log.error("releaseRedis exception:" + e.getMessage(), e);
		}
	}
}
